<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Print Sentinel</title>
    <link rel="stylesheet" href="{{ url_for('static', path='css/style.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', path='css/style-additions.css') }}">
</head>
<body>

    <div id="subscriptionModal" class="modal">
        <div class="modal-content">
            <h2>Print Sentinel</h2>
            <p>Little explanation on what Subscribe is.</p>
            <div class="modal-buttons">
                <button id="subscribeBtnModal">Subscribe</button>
                <button id="continueWithoutSubBtn" class="button-secondary">Continue without Sub</button>
            </div>
        </div>
    </div>

    <header class="app-header">
        <h1>Print Sentinel</h1>
    </header>

    <div class="container">
        <div class="main-layout">
            <section class="video-section">
                <h2>Live Video Feed</h2>
                <img id="videoPreview" src="{{ url_for('camera_feed') }}" alt="Live Video Feed Preview" />
                <label for="cameraSelect" class="camera-select-label">Select Camera:</label>
                <select id="cameraSelect" name="camera">
                    <option value="0" {% if camera_index == 0 %}selected{% endif %}>Camera 0</option>
                    <option value="1" {% if camera_index == 1 %}selected{% endif %}>Camera 1</option>
                    <option value="2" {% if camera_index == 2 %}selected{% endif %}>Camera 2</option>
                </select>
            </section>

            <section class="controls-section">
                <div class="desktop-controls-text">
                    <h2>Controls</h2>
                    <p>Something here for starting and stopping live detection. And live imaging throughput.</p>
                </div>
                 <div class="mobile-controls">
                    <h2>Controls</h2>
                </div>
                <div class="start-stop-buttons">
                    <button id="startBtn">Start</button>
                    <button id="stopBtn" class="button-secondary">Stop</button>
                </div>

                <div class="status-area" id="statusArea">
                    <!-- Status will be updated here by JavaScript -->
                    <div class="status-inactive">Detection Inactive</div>
                    <!-- Example States (to be shown/hidden via JS):
                    <div class="status-defect">
                        Defect Detected!
                        <div class="defect-details">
                            <img src="placeholder_defect_image.png" alt="Defect Screenshot">
                            <p>Screenshot Time: 00:00</p>
                            <p>Alert Countdown: 00:00</p>
                            <button class="button-secondary">Dismiss</button>
                        </div>
                    </div>
                    <div class="status-no-defect">
                        No defects detected.
                    </div>
                    -->
                </div>
                 <div class="settings-button-container">
                    <button id="settingsBtn" onclick="window.location.href='/settings'">Settings</button>
                    <button id="pushSubscribeBtn" class="button-secondary">Subscribe to Notifications</button>
                    <button id="testPushBtn" class="button-secondary">Send Test Notification</button>
                </div>
            </section>
        </div>
    </div>

    <script>
        function setCookie(name, value, days) {
            let expires = "";
            if (days) {
                const date = new Date();
                date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
                expires = "; expires=" + date.toUTCString();
            }
            document.cookie = name + "=" + (value || "") + expires + "; path=/";
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length);
            }
            return null;
        }

        // Basic Modal Logic
        const modal = document.getElementById('subscriptionModal');
        const subscribeButton = document.getElementById('subscribeBtnModal');
        const continueButton = document.getElementById('continueWithoutSubBtn');
        const legacySubscribeButton = document.getElementById('subscribe');

        if (legacySubscribeButton && legacySubscribeButton !== subscribeButton) {
            legacySubscribeButton.style.display = 'none';
        }
        
        if (!localStorage.getItem('visitedPrintSentinel')) {
            modal.style.display = 'block';
            localStorage.setItem('visitedPrintSentinel', 'true');
        }

        subscribeButton.onclick = function() {
            modal.style.display = 'none';
            console.log("Subscribe clicked");
            triggerNotificationSubscription(); 
        }

        continueButton.onclick = function() {
            modal.style.display = 'none';
            console.log("Continue without subscribing");
        }

        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        }

        async function registerSW() {
            if (!navigator.serviceWorker.controller) {
                const reg = await navigator.serviceWorker.register('/sw.js', { scope: '/' });
                console.log('Service Worker registered with scope:', reg.scope);
            }
            const registration = await navigator.serviceWorker.ready;
            console.log('Service Worker ready:', registration);
            return registration;
        }

        async function triggerNotificationSubscription() {
            if (!('serviceWorker' in navigator)) {
                alert('Service workers not supported');
                return;
            }
            if (!('PushManager' in window)) {
                alert('Push messaging not supported');
                return;
            }
            try {
                const registration = await registerSW();
                console.log('Service Worker registration obtained:', registration);

                const permission = await Notification.requestPermission();
                if (permission !== 'granted') {
                    alert('Permission denied for notifications');
                    return;
                }

                console.log('Fetching public key from: {{ url_for('route_public_key_ep') }}');
                const response = await fetch("{{ url_for('route_public_key_ep') }}");
                if (!response.ok) {
                    throw new Error(`Public key fetch failed: ${response.status} ${response.statusText}`);
                }
                const data = await response.json();
                const publicKey = data.public_key;
                if (!publicKey) {
                    throw new Error('Empty public key returned');
                }

                let subscription = await registration.pushManager.getSubscription();
                if (!subscription) {
                    subscription = await registration.pushManager.subscribe({
                        userVisibleOnly: true,
                        applicationServerKey: urlBase64ToUint8Array(publicKey)
                    });
                    console.log('New subscription created');
                } else {
                    console.log('Using existing subscription');
                }

                console.log('Obtained PushSubscription:', subscription);
                console.log('Subscription endpoint:', subscription.endpoint);
                console.log('Subscription keys:', subscription.toJSON().keys);

                console.log('Sending subscription to: {{ url_for('route_subscribe_ep') }}');
                const res = await fetch("{{ url_for('route_subscribe_ep') }}", { // Adjusted path
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(subscription)
                });
                console.log('Subscription POST response:', res);
                if (!res.ok) {
                    const errorText = await res.text();
                    throw new Error(`Subscription failed: ${res.status} ${errorText}`);
                }
                setCookie('pushSubscribed', 'true', 365);
                alert('Subscribed to notifications successfully!');
                const resultJson = await res.json();
                const subId = resultJson.subscription_id;
                console.log('Stored subscription ID:', subId);
                localStorage.setItem('pushSubId', subId);
                try {
                    const testMsg = { title: 'Test Notification', body: 'Push is working!', url: window.location.origin };
                    const testRes = await fetch(`/notifications/send/${subId}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(testMsg)
                    });
                    console.log('Test notification response:', testRes);
                } catch (e) {
                    console.error('Error sending test notification:', e);
                }
            } catch (err) {
                console.error('Subscription error:', err);
                alert('Error during notification subscription: ' + (err.message || err));
            }
        }
        
        function urlBase64ToUint8Array(base64String) {
            const padding = '='.repeat((4 - base64String.length % 4) % 4);
            const base64 = (base64String + padding)
                .replace(/-/g, '+')
                .replace(/_/g, '/');
            const rawData = atob(base64);
            return new Uint8Array([...rawData].map(char => char.charCodeAt(0)));
        }

        const statusArea = document.getElementById('statusArea');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const videoPreview = document.getElementById('videoPreview');

        let liveEventSource = null;

        async function startLiveDetection() {
            const selectedCam = parseInt(cameraSelect.value, 10);
            
            if (!cameraStatuses[selectedCam] || !cameraStatuses[selectedCam].running) {
                await fetch("{{ url_for('start_live_detection') }}", { method: 'POST' });
            }
            
            if (liveEventSource) liveEventSource.close();

            liveEventSource = new EventSource("{{ url_for('live_detection_feed') }}");
            liveEventSource.onmessage = (e) => {
                const data = JSON.parse(e.data);

                if (data.error) {
                    console.error(`Camera error: ${data.error}`);
                    statusArea.innerHTML = `<div class="status-error">
                        ${data.error}
                        <small>(Camera ${data.camera_index !== undefined ? data.camera_index : selectedCam})</small>
                        <button onclick="retryCamera(${data.camera_index !== undefined ? data.camera_index : selectedCam})" class="button-secondary">Retry Camera</button>
                    </div>`;
                    
                    const camIdx = data.camera_index !== undefined ? data.camera_index : selectedCam;
                    if (!cameraStatuses[camIdx]) {
                        cameraStatuses[camIdx] = {};
                    }
                    cameraStatuses[camIdx].error = data.error;
                    return;
                }

                if (data.camera_index !== undefined && parseInt(data.camera_index, 10) === parseInt(cameraSelect.value, 10)) {
                    if (!cameraStatuses[data.camera_index]) {
                        cameraStatuses[data.camera_index] = {};
                    }
                    cameraStatuses[data.camera_index].last_result = data.result;
                    cameraStatuses[data.camera_index].last_time = data.time;
                    cameraStatuses[data.camera_index].running = true;
                    cameraStatuses[data.camera_index].error = null;
                    
                    statusArea.innerHTML = `<div class="status-${data.result.toLowerCase().replace(/\s+/g, '-')}">
                        ${data.result} @ ${new Date(data.time * 1000).toLocaleTimeString()}
                        <small>(Camera ${data.camera_index})</small>
                    </div>`;
                }
            };
            
            liveEventSource.onerror = (e) => {
                console.error("EventSource failed:", e);
                if (liveEventSource) { liveEventSource.close(); liveEventSource = null; }
                statusArea.innerHTML = `<div class="status-error">
                    Error connecting to live feed for camera ${selectedCam}
                    <small>Check console for details</small>
                    <button onclick="retryCamera(${selectedCam})" class="button-secondary">Retry Camera</button>
                </div>`;
                videoPreview.src = "{{ url_for('camera_feed') }}?_=" + Date.now();
                
                if (cameraStatuses[selectedCam]) {
                    cameraStatuses[selectedCam].running = false;
                    cameraStatuses[selectedCam].error = "Connection error";
                }
            };
        }

        async function stopLiveDetection() {
            const selectedCam = parseInt(cameraSelect.value, 10);
            await fetch("{{ url_for('stop_live_detection') }}", { method: 'POST' });
            
            if (liveEventSource) { 
                liveEventSource.close(); 
                liveEventSource = null; 
            }
            
            statusArea.innerHTML = `<div class="status-inactive">Detection Inactive for Camera ${selectedCam}</div>`;
            videoPreview.src = "{{ url_for('camera_feed') }}?_=" + Date.now();

            if (cameraStatuses[selectedCam]) {
                cameraStatuses[selectedCam].running = false;
                cameraStatuses[selectedCam].last_result = null;
                cameraStatuses[selectedCam].last_time = null;
            }
        }

        startBtn.removeEventListener('click', null);
        stopBtn.removeEventListener('click', null);
        startBtn.addEventListener('click', startLiveDetection);
        stopBtn.addEventListener('click', stopLiveDetection);

        const cameraStatuses = {};

        async function syncLiveStatus() {
            try {
                const res = await fetch('/live/status');
                if (!res.ok) return;
                const { running, camera_index: activeCam, camera_statuses } = await res.json();
                const selectedCam = parseInt(cameraSelect.value, 10);

                Object.assign(cameraStatuses, camera_statuses || {});
                
                if (cameraStatuses[selectedCam] && cameraStatuses[selectedCam].error) {
                    statusArea.innerHTML = `<div class="status-error">
                        ${cameraStatuses[selectedCam].error}
                        <small>(Camera ${selectedCam})</small>
                    </div>`;
                    return;
                }
                
                const currentCamStatus = cameraStatuses[selectedCam] || { running: false };
                
                if (currentCamStatus.running && !liveEventSource) {
                    liveEventSource = new EventSource("{{ url_for('live_detection_feed') }}");
                    liveEventSource.onmessage = (e) => {
                        const data = JSON.parse(e.data);

                        if (data.camera_index !== undefined && parseInt(data.camera_index, 10) === selectedCam) {
                            if (!cameraStatuses[data.camera_index]) {
                                cameraStatuses[data.camera_index] = {};
                            }
                            cameraStatuses[data.camera_index].last_result = data.result;
                            cameraStatuses[data.camera_index].last_time = data.time;
                            cameraStatuses[data.camera_index].running = true;

                            statusArea.innerHTML = `<div class="status-${data.result.toLowerCase().replace(/\s+/g, '-')}">
                                ${data.result} @ ${new Date(data.time * 1000).toLocaleTimeString()}
                                <small>(Camera ${data.camera_index})</small>
                            </div>`;
                        }
                    };
                    
                    liveEventSource.onerror = (e) => {
                        console.error("EventSource failed:", e);
                        if (liveEventSource) { liveEventSource.close(); liveEventSource = null; }
                        statusArea.innerHTML = `<div class="status-inactive">Error connecting to live feed for camera ${selectedCam}. Check console.</div>`;
                        videoPreview.src = "{{ url_for('camera_feed') }}";
                    };
                } 
                else if (!currentCamStatus.running && liveEventSource) {
                    liveEventSource.close();
                    liveEventSource = null;
                    statusArea.innerHTML = `<div class="status-inactive">Detection Inactive for camera ${selectedCam}</div>`;
                }
                else if (liveEventSource && currentCamStatus.running) {
                    const statusClass = currentCamStatus.last_result ? 
                        `status-${currentCamStatus.last_result.toLowerCase().replace(/\s+/g, '-')}` : 
                        'status-inactive';
                    const timeDisplay = currentCamStatus.last_time ? 
                        new Date(currentCamStatus.last_time * 1000).toLocaleTimeString() :
                        'N/A';
                    
                    statusArea.innerHTML = `<div class="${statusClass}">
                        ${currentCamStatus.last_result || 'Unknown'} @ ${timeDisplay}<br>
                        <small>Camera ${selectedCam} - Detection Active</small>
                    </div>`;
                }
                else if (!currentCamStatus.running) {
                    statusArea.innerHTML = `<div class="status-inactive">Detection inactive for camera ${selectedCam}</div>`;

                    if (videoPreview.src.indexOf('_=') === -1) {
                        videoPreview.src = "{{ url_for('camera_feed') }}?_=" + Date.now();
                    }
                }
            } catch (e) {
                console.error('Error syncing live status:', e);
            }
        }
        window.addEventListener('load', syncLiveStatus);
        setInterval(syncLiveStatus, 5000);

        function showDefect(imageUrl, time, countdown) {
            statusArea.innerHTML = `
                <div class="status-defect">
                    Defect Detected!
                    <div class="defect-details">
                        <img src="${imageUrl}" alt="Defect Screenshot">
                        <p>Screenshot Time: ${time}</p>
                        <p>Alert Countdown: ${countdown}</p>
                        <button class="button-secondary" onclick="dismissDefect()">Dismiss</button>
                    </div>
                </div>`;
        }

        function dismissDefect() {
            statusArea.innerHTML = '<div class="status-inactive">Detection Inactive (Defect Dismissed)</div>';
        }
        
        async function retryCamera(cameraIndex) {
            try {
                if (cameraStatuses[cameraIndex] && cameraStatuses[cameraIndex].running) {
                    await fetch("{{ url_for('stop_live_detection') }}", { method: 'POST' });
                }
                
                if (parseInt(cameraSelect.value, 10) !== cameraIndex) {
                    await fetch("{{ url_for('set_camera_index') }}", {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ camera_index: cameraIndex })
                    });
                    cameraSelect.value = cameraIndex;
                    document.getElementById('videoPreview').src = "{{ url_for('camera_feed') }}?_=" + Date.now();
                }
                
                if (cameraStatuses[cameraIndex]) {
                    cameraStatuses[cameraIndex].error = null;
                }
                
                statusArea.innerHTML = `<div class="status-inactive">Attempting to reconnect to camera ${cameraIndex}...</div>`;

                await startLiveDetection();
            } catch (e) {
                console.error(`Error retrying camera ${cameraIndex}:`, e);
                statusArea.innerHTML = `<div class="status-error">
                    Failed to reconnect to camera ${cameraIndex}
                    <small>${e.message || 'Unknown error'}</small>
                    <button onclick="retryCamera(${cameraIndex})" class="button-secondary">Retry Again</button>
                </div>`;
            }
        }

        const settingsBtn = document.getElementById('settingsBtn');
        settingsBtn.addEventListener('click', () => {
            window.location.href = "{{ url_for('settings_page') }}";
        });

        const cameraSelect = document.getElementById('cameraSelect');
        cameraSelect.addEventListener('change', async () => {
            const idx = parseInt(cameraSelect.value, 10);

            if (liveEventSource) {
                liveEventSource.close();
                liveEventSource = null;
            }

            await fetch("{{ url_for('set_camera_index') }}", {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ camera_index: idx })
            });

            document.getElementById('videoPreview').src = "{{ url_for('camera_feed') }}?_=" + Date.now();

            const camStatus = cameraStatuses[idx];

            if (camStatus && camStatus.error) {
                statusArea.innerHTML = `<div class="status-error">
                    ${camStatus.error}
                    <small>(Camera ${idx})</small>
                </div>`;
                return;
            }
            
            if (camStatus && camStatus.running) {
                startLiveDetection();
                
                const statusClass = camStatus.last_result ? 
                    `status-${camStatus.last_result.toLowerCase().replace(/\s+/g, '-')}` : 
                    'status-active';
                const timeDisplay = camStatus.last_time ? 
                    new Date(camStatus.last_time * 1000).toLocaleTimeString() :
                    'N/A';
                
                statusArea.innerHTML = `<div class="${statusClass}">
                    ${camStatus.last_result || 'Active'} @ ${timeDisplay}<br>
                    <small>(Camera ${idx})</small>
                </div>`;
                
                startLiveDetection();
            } else {
                statusArea.innerHTML = `<div class="status-inactive">Detection Inactive for Camera ${idx}</div>`;
            }

            syncLiveStatus();
        });

        const pushSubscribeBtn = document.getElementById('pushSubscribeBtn');
        if (pushSubscribeBtn) {
            pushSubscribeBtn.addEventListener('click', () => {
                console.log('Manual subscribe button clicked');
                triggerNotificationSubscription();
            });
        }

        const testPushBtn = document.getElementById('testPushBtn');
        if (testPushBtn) {
            testPushBtn.addEventListener('click', async () => {
                const subId = localStorage.getItem('pushSubId');
                if (!subId) {
                    alert('No stored subscription ID. Please subscribe first.');
                    return;
                }
                const msg = { title: 'Test Notification', body: 'This is a test push.', url: window.location.href };
                try {
                    const res = await fetch(`/notifications/send/${subId}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(msg)
                    });
                    console.log('Test notification response:', res);
                    if (res.ok) {
                        alert('Test notification sent!');
                    } else {
                        const err = await res.text();
                        alert('Failed to send test notification: ' + err);
                    }
                } catch (e) {
                    console.error('Error sending test notification:', e);
                    alert('Error sending test notification: ' + e);
                }
            });
        }

        (function() {
            const countdownStart = {{ countdown_time }};
            const alertSource = new EventSource("{{ url_for('live_alerts_feed') }}");
            alertSource.onmessage = e => {
                const { alert_id, timestamp, camera_index } = JSON.parse(e.data);
                showAlertOverlay(alert_id, timestamp, camera_index);
            };

            function showAlertOverlay(id, ts, cameraIndex) {
                if (document.getElementById(`alert-overlay-${id}`)) return;
                const overlay = document.createElement('div');
                overlay.id = `alert-overlay-${id}`;
                overlay.style.cssText = 'position:fixed;top:20px;right:20px;background:#fff;border:2px solid #f00;z-index:10000;padding:15px;max-width:300px;box-shadow:0 0 10px rgba(0,0,0,0.5);';
                const img = document.createElement('img');
                img.src = `/alert/${id}/snapshot`;
                img.style.width = '100%';
                overlay.appendChild(img);
                const cameraP = document.createElement('p');
                cameraP.style.fontWeight = 'bold';
                cameraP.textContent = cameraIndex !== undefined ? `Camera ${cameraIndex}` : 'Unknown Camera';
                overlay.appendChild(cameraP);
                const timeP = document.createElement('p');
                timeP.textContent = 'Detected at: ' + new Date(ts * 1000).toLocaleTimeString();
                overlay.appendChild(timeP);
                const countdownP = document.createElement('p');
                const elapsed = Math.floor(Date.now() / 1000 - ts);
                let remaining = countdownStart - elapsed;
                if (remaining < 0) remaining = 0;
                countdownP.textContent = `Dismiss in: ${remaining}s`;
                overlay.appendChild(countdownP);
                const timer = setInterval(() => {
                    remaining -= 1;
                    if (remaining <= 0) {
                        clearInterval(timer);
                        removeOverlay();
                    } else {
                        countdownP.textContent = `Dismiss in: ${remaining}s`;
                    }
                }, 1000);
                const btnDismiss = document.createElement('button');
                btnDismiss.textContent = 'Dismiss';
                btnDismiss.onclick = () => { clearInterval(timer); removeOverlay(); dismissAlert(id); };
                overlay.appendChild(btnDismiss);
                const btnCancel = document.createElement('button');
                btnCancel.textContent = 'Cancel Print';
                btnCancel.style.marginLeft = '8px';
                btnCancel.onclick = () => { clearInterval(timer); removeOverlay(); cancelPrint(); dismissAlert(id); };
                overlay.appendChild(btnCancel);
                document.body.appendChild(overlay);

                function removeOverlay() {
                    overlay.remove();
                }
            }

            async function dismissAlert(id) {
                try {
                    await fetch(`/alert/${id}/dismiss`, { method: 'POST' });
                } catch (e) { console.error('Dismiss alert failed', e); }
            }

            function cancelPrint() {
                console.log('Cancel print requested');
            }
        })();
    </script>
</body>
</html>
